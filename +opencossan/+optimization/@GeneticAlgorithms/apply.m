function optimum = apply(obj, varargin)
%   APPLY   This method applies the algorithm
%           GeneticAlgorithms for optimization
%
%   GeneticAlgorithms is intended for solving an optimization
%   problem using evaluations of the objective function and constraints,
%   i.e. gradients are not required.
%
%   GeneticAlgorithms is intended for solving the following
%   class of problems
%
%                       min     f_obj(x)
%                       subject to
%                               ceq(x)      =  0
%                               cineq(x)    <= 0
%                               lb <= x <= ub
%
% See also: https://cossan.co.uk/wiki/index.php/apply@GeneticAlgorithms
%
% Author: Edoardo Patelli 
% Institute for Risk and Uncertainty, University of Liverpool, UK
% email address: openengine@cossan.co.uk
% Website: http://www.cossan.co.uk

%{
This file is part of OpenCossan <https://cossan.co.uk>.
Copyright (C) 2006-2018 COSSAN WORKING GROUP

OpenCossan is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License or,
(at your option) any later version.

OpenCossan is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenCossan. If not, see <http://www.gnu.org/licenses/>.
%}

import opencossan.optimization.OptimizationRecorder;
import opencossan.common.utilities.*;

[required, varargin] = parseRequiredNameValuePairs(...
    "optimizationproblem", varargin{:});

optProb = required.optimizationproblem;

optional = parseOptionalNameValuePairs(...
    ["initialsolution", "plotevolution"], {optProb.InitialSolution, false}, ...
    varargin{:});

x0 = optional.initialsolution;
plotEvolution = optional.plotevolution;
%  Check whether or not required arguments have been passed

% Check inputs and initialize variables
obj = initializeOptimizer(obj);

% Create handle of the objective function
hobjfun=@(x)evaluate(optProb.ObjectiveFunctions,'optimizationproblem', optProb, ...
    'referencepoints',x , ...
    'scaling', obj.ObjectiveFunctionScalingFactor);

% Create handle of the objective function
hconstrains=@(x)evaluate(optProb.Constraints,'optimizationproblem', optProb, ...
    'referencepoints', x, ...
    'scaling', obj.ConstraintScalingFactor);

assert(size(x0, 1) <= obj.NPopulationSize, ...
    'OpenCossan:GeneticAlgorithms:apply', ...
    ['Initial population must be less the NpopulationSize (' num2str(obj.NPopulationSize) ')'])

assert(size(x0, 2) == length(optProb.DesignVariableNames), ...
    'OpenCossan:GeneticAlgorithms:apply', ...
    'Initial solution must contain a number of columns equal to the number of design variables');

%% Prepare options structure for GeneticAlgorithms
Toptions                    = gaoptimset;                %Default optimization options
Toptions.InitialPopulation  = x0;      % Define the initial population
Toptions.PopulationSize     = obj.NPopulationSize;      %scalar, number of individuals in population
Toptions.EliteCount         = obj.NEliteCount;          %scalar, indicates the number of elite individuals that are passed directly to the next generation
Toptions.CrossoverFraction  = obj.crossoverFraction;    %percentage of individuals of the next generation that are generated by means of crossover operations
Toptions.Generations        = obj.MaxIterations;         %scalar defining maximum number of generations to be created
Toptions.StallGenLimit      = obj.NStallGenLimit;       %scalar; the optimization algorithm stops if there has been no improvement in the objective function for 'NStallGenLimit' consecutive generations
Toptions.TolFun             = obj.ObjectiveFunctionTolerance;   %Termination criterion w.r.t. objective function; algorithm is stopped if the  cumulative change of the fitness function over 'NStallGenLimit' is less than 'ToleranceObjectiveFunction'
Toptions.TolCon             = obj.ConstraintTolerance;          %Defines tolerance w.r.t. constraints
Toptions.InitialPenalty     = obj.initialPenalty;               %Initial value of penalty parameter; used in constrained optimization
Toptions.PenaltyFactor      = obj.PenaltyFactor;                %parameter for updating the penalty factor; required in constrained optimization
Toptions.FitnessScalingFcn  = str2func(obj.SFitnessScalingFcn); %eval(['@' SFitnessScalingFcn]);   %scaling of fitness function
Toptions.SelectionFcn       = str2func(obj.SSelectionFcn);      %eval(['@' SSelectionFcn]);        %function for selecting parents for crossover and mutation
Toptions.CrossoverFcn       = str2func(obj.SCrossoverFcn);      %eval(['@' SCrossoverFcn]);        %function for generating crossover children
Toptions.MutationFcn       = str2func(obj.SMutationFcn);
Toptions.CreationFcn       = str2func(obj.SCreationFcn);
Toptions.Display            = 'iter';    %sets level of display
Toptions.Vectorized         = 'on';     %enables possibility of calculating fitness of population using a single function callXop.VlowerBounds,Xop.VupperBounds
Toptions.TimeLimit          = obj.Timeout; % termination criteria
% Toptions.OutputFcns = @obj.outputFunction;

opencossan.optimization.OptimizationRecorder.clear();

startTime = tic;
if isempty(optProb.Constraints)
    if plotEvolution
        Toptions = gaoptimset('PlotFcns',{@gaplotbestf});
    end
    
    if ~obj.LextremeOptima
        % Run constrained optimisation
        [optimalSolution,~,exitFlag, ~] =ga(hobjfun,...
            Xop.NumberOfDesignVariables,[],[],[],[],optProb.LowerBounds,optProb.UpperBounds,...
            [],Toptions);
    else
        % Run unconstrained extreme-values optimization with bounded
        % design variables
        [optimalSolution,~,exitFlag,~] =ga_minmax(hobjfun,...
            optProb.NumberOfDesignVariables,[],[],[],[],...
            optProb.LowerBounds,optProb.UpperBounds,[],Toptions);
    end
    
else
    
    if plotEvolution
        Toptions = gaoptimset('PlotFcns',{@gaplotbestf,@gaplotmaxconstr});
    end
    
    if ~obj.LextremeOptima
        % Run constrained optimisation
        [optimalSolution,~,exitFlag, ~] =ga(hobjfun,...
            optProb.NumberOfDesignVariables,[],[],[],[],optProb.LowerBounds,optProb.UpperBounds,...
            hconstrains,...
            Toptions);
    else
        % Run unconstrained extreme-values optimization with bounded
        % design variables
        [optimalSolution,~,exitFlag,~] =ga_minmax(hobjfun,...
            optProb.NumberOfDesignVariables,[],[],[],[],...
            optProb.LowerBounds,optProb.UpperBounds,[],Toptions);
    end
end

totalTime = toc(startTime);

optimum = opencossan.optimization.Optimum(...
    'optimalsolution', optimalSolution, ...
    'exitflag', exitFlag, ...
    'totaltime', totalTime, ...
    'optimizationproblem', optProb, ...
    'optimizer', obj, ...
    'constraints', OptimizationRecorder.getInstance().Constraints, ...
    'objectivefunction', OptimizationRecorder.getInstance().ObjectiveFunction, ...
    'modelevaluations', OptimizationRecorder.getInstance().ModelEvaluations);

if ~isdeployed
    % add entries in simulation and analysis database at the end of the
    % computation when not deployed. The deployed version does this with
    % the finalize command
    XdbDriver = opencossan.OpenCossan.getDatabaseDriver;
    if ~isempty(XdbDriver)
        XdbDriver.insertRecord('StableType','Result',...
            'Nid',getNextPrimaryID(OpenCossan.getDatabaseDriver,'Result'),...
            'CcossanObjects',{Xoptimum},...
            'CcossanObjectsNames',{'Xoptimum'});
    end
end

end

